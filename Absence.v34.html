
<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>打卡紀錄分析</title>
<style>
    /* 放在 <style> 的最上面 */
*, *::before, *::after { box-sizing: border-box; }

  :root{--bg:#f7f7fb;--card:#fff;--ink:#1f2937;--muted:#6b7280;--pri:#4f46e5;--border:#e5e7eb}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,"Noto Sans TC","Segoe UI",Roboto,Arial,"PingFang TC","Microsoft JhengHei","Helvetica Neue",sans-serif}
  .wrap{max-width:1200px;margin:24px auto;padding:0 16px}
  .title{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
  .title h1{margin:0;font-size:20px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:16px;box-shadow:0 1px 3px rgba(0,0,0,.04);padding:16px}
  textarea{
  width:100%;
  max-width:100%;
  height:260px;
  border:1px solid var(--border);
  border-radius:12px;
  padding:12px;
  font:12px/1.4 ui-monospace,Menlo,Consolas,monospace;
  display:block;          /* 防止和 inline 元素並排造成怪寬 */
  resize:vertical;        /* 只允許上下拉高，不橫向撐寬（可選） */
}

  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  /* Buttons -Blue */
button{
  appearance:none;
  border:0;
  border-radius:8px;
  background:#e3f2fd;
  color:#1565c0;
  padding:14px 20px;
  font-weight:600;
  cursor:pointer;
  display:inline-flex;
  align-items:center;
  gap:8px;
  box-shadow:0 2px 6px rgba(21,101,192,0.3);
  transition:background .2s, box-shadow .2s, transform .04s;
}
button:hover{
  background:#cde5fd;
  box-shadow:0 4px 12px rgba(21,101,192,0.5);
}
button:active{
  transform:translateY(1px);
}
button:focus-visible{
  outline:2px solid #1a73e8;
  outline-offset:2px;
}

/* 次要按鈕（灰階） */
button.secondary{
  background:#f1f5f9;
  color:#334155;
  box-shadow:0 1px 3px rgba(2,6,23,0.12);
}
button.secondary:hover{
  background:#e2e8f0;
  box-shadow:0 3px 8px rgba(2,6,23,0.18);
}

  .muted{color:var(--muted);font-size:12px;margin-top:6px}
  table{width:100%;border-collapse:collapse}
  th,td{border:1px solid var(--border);padding:8px 10px;vertical-align:top}
  th{background:#f3f4f6;text-align:left}
  .hint{font-size:12px;color:var(--muted)}
    /* 早退/曠職警示 */
  .danger{ color:#dc2626; font-weight:700 }

  /* Toast */
  .toast-wrap{
    position:fixed; right:16px; bottom:16px; z-index:9999; display:flex; flex-direction:column; gap:8px;
  }
  .toast{
    background:#111827; color:#fff; padding:10px 14px; border-radius:10px; 
    box-shadow:0 8px 24px rgba(0,0,0,.12); max-width:520px; font-size:14px; line-height:1.4;
  }
  .toast b{color:#fca5a5}

</style>
</head>
<body>
  <div class="wrap">
    <div class="title">
      <h1>貼上打卡之星匯出的"打卡紀錄"</h1>
    </div>

    <div class="muted">直接貼上打卡紀錄(勿有隱藏"行"會分析失敗)。一天工時固定 <b>8 小時</b>。</div>

    <div class="card" style="margin-top:12px">
      <textarea id="raw" placeholder="在這裡貼上原始資料（含或不含表頭；欄位以 Tab 分隔）"></textarea>
      <div class="row" style="margin-top:8px">
        <button id="run">整理打卡紀錄並產生表格</button>
        <button id="clear" class="secondary">清空</button>
      </div>
    </div>

    <div id="out" class="card" style="margin-top:12px">
      <div class="hint">尚未輸出。</div>
    </div>
  </div>
<div id="toast" class="toast-wrap" aria-live="polite"></div>
<script>
(function(){
  const $ = (sel)=>document.querySelector(sel);
  const DAY_HRS = 8; // 固定一天 8 小時
  // 遲到免扣設定：每人每月可免扣 3 次、每次限 5 分鐘以內；且優先免扣分鐘數較大的
  const FREE_LATE_COUNT = 3;
  const FREE_LATE_MIN   = 5;

  // 計次型的類別（新增）
  const COUNT_TYPES = new Set(["漏打卡","非出勤日打卡"]);


  const headersDefault = [
    "員工編號","姓名","部門","打卡日期","日期類別","班別","表定上班時間","表定下班時間",
    "休息時間","表定工時","打卡工時","計薪基準工時","上班打卡時間","遲到","下班打卡時間","早退",
    "出勤異常","提早上班原因","上班打卡方式","上班打卡地點","上班地點異常，不在範圍內的原因",
    "延後下班原因","下班打卡方式","下班打卡地點","下班地點異常，不在範圍內的原因",
    "請假時間","請假時數","假別","加班時間","加班時數"
  ];

  // 事件
  $("#run").addEventListener("click", run);
  $("#clear").addEventListener("click", ()=>{ $("#raw").value=""; $("#out").innerHTML='<div class="hint">尚未輸出。</div>'; });

  // 主流程
  let lastTSV = ""; // for copy
  function run(){
    const text = ($("#raw").value||"").trim();
    const out = $("#out");
    if(!text){ out.innerHTML = '<div class="hint">（請先貼上資料）</div>'; return; }

    const {headers, rows, err} = tsvParse(text);
    if(err){ out.innerHTML = `<div style="color:#dc2626">解析失敗：${err}</div>`; return; }

    const H_DATE   = pickHeader(headers, /打卡日期/, "打卡日期");
    const H_NAME   = pickHeader(headers, /姓名/, "姓名");
    const H_BRANCH = pickHeader(headers, /分校|部門/, "部門"); // 從資料抓
    const H_LEAVE_H    = pickHeader(headers, /請假時數/, "請假時數");
    const H_LEAVE_KIND = pickHeader(headers, /假別/, "假別");
    const H_OT_H     = pickHeader(headers, /^(加班時數|加班工時)$/, "加班時數");
    const H_OT_TIME  = pickHeader(headers, /^加班時間$/, "加班時間");
    const H_ABN   = pickHeader(headers, /出勤異常/, "出勤異常");

    // 聚合：key = 年月|分校|姓名|類型
    const map = new Map();

    rows.forEach(r=>{
      const dateStr = (r[H_DATE]||"").trim();
      const ym = toYM(dateStr);
      const md = toMD(dateStr); // 8/19
      const name = (r[H_NAME]||"").trim();
      const branch = (r[H_BRANCH]||"").trim();
      const abn = (r[H_ABN]||"").trim();

      // 1) 請假（小時計）—保留原功能
      const leaveKind = (r[H_LEAVE_KIND]||"").replace(/\s/g,"");
      const leaveH = hhmmToHours(r[H_LEAVE_H]);
      if(leaveKind && leaveKind!=="--" && leaveH>0){
        addAgg(map, ym, branch, name, leaveKind, leaveH, `${md} ${fmtPiece(leaveH, DAY_HRS)}`, DAY_HRS);
      }

      // 2) 超時（加班）—保留原功能（支援「加班時數=數字」或「加班時間=hh:mm(:ss)」）
      const otFromTime = hhmmToHours(r[H_OT_TIME]);           // 例如 "01:30:00" → 1.5
      const otH        = (H_OT_H && r[H_OT_H]) ? toNumber(r[H_OT_H]) : 0; // 純數字小時
      const ot         = (otFromTime || 0) > 0 ? otFromTime : otH;        // 先用時間，有再用小時
      if (ot > 0) {
         addAgg(map, ym, branch, name, "超時", ot, `${md} ${fmtPiece(ot, DAY_HRS)}`, DAY_HRS);
      }


      // 3) 出勤異常：分鐘型（遲到/早退/曠職）＋ 計次型（漏打卡/非出勤日打卡/補打卡單/其他異常）
      if (abn && abn !== "--") {
        // 以「、」切片，避免「遲到 X 分鐘、下班未打卡」漏算
        const parts = String(abn).split(/、/).map(s => s.trim()).filter(Boolean);

        parts.forEach(p => {
          // 1) 遲到：含「不扣」視為「遲到(不扣)」，否則「遲到⚠️」
          let m = p.match(/遲到\s*(\d+)\s*分/);
          if (m) {
            const mins = Number(m[1]);
            const typ = /不扣/.test(p) ? "遲到(不扣)" : "遲到⚠️";
            addAgg(map, ym, branch, name, typ, { mins, cnt:1 }, `${md} ${mins}分鐘`, DAY_HRS, true);
            return;
          }

          // 2) 早退 X 分鐘
          m = p.match(/早退\s*(\d+)\s*分/);
          if (m) {
            const mins = Number(m[1]);
            addAgg(map, ym, branch, name, "早退", { mins, cnt:1 }, `${md} ${mins}分鐘`, DAY_HRS, true);
            return;
          }

          // 3) 曠職 X 分鐘
          m = p.match(/曠職\s*(\d+)\s*分/);
          if (m) {
            const mins = Number(m[1]);
            addAgg(map, ym, branch, name, "曠職", { mins, cnt:1 }, `${md} ${mins}分鐘`, DAY_HRS, true);
            return;
          }

          // 4) 上/下班未打卡／漏打卡（可同時出現、也可寫成「…X 次」）
          const timesM = p.match(/(\d+)\s*次/);
          let totalTimes = timesM ? Number(timesM[1]) : 0;
          const upMiss   = (p.match(/上班未打卡/gi) || []).length;
          const downMiss = (p.match(/下班未打卡/gi) || []).length;
          const plainMiss = (!upMiss && !downMiss) ? (p.match(/漏打卡/gi) || []).length : 0;

          if (!timesM) totalTimes = upMiss + downMiss + plainMiss;
          if (totalTimes > 0) {
            for (let i=0;i<upMiss;i++)   addAgg(map, ym, branch, name, "漏打卡", { miss:1 }, `${md} 上班`, DAY_HRS, true);
            for (let i=0;i<downMiss;i++) addAgg(map, ym, branch, name, "漏打卡", { miss:1 }, `${md} 下班`, DAY_HRS, true);
            for (let i=0;i<Math.max(0, totalTimes - upMiss - downMiss); i++) {
              addAgg(map, ym, branch, name, "漏打卡", { miss:1 }, `${md}`, DAY_HRS, true);
            }
            return;
          }

          // 5) 非出勤日打卡（將以加班單為準） → 計次
          //if (/非出勤日打卡/.test(p)) {
          //addAgg(map, ym, branch, name, "非出勤日打卡", { cnt:1 }, `${md}`, DAY_HRS, true);
          //return;
          //}

          // 6) 上/下班時間由忘打卡單建立 → 計次（視為補單）
          if (/時間由忘打卡單建立/.test(p)) {
            const when = /上班/.test(p) ? "上班" : (/下班/.test(p) ? "下班" : "");
            addAgg(map, ym, branch, name, "補打卡單", { cnt:1 }, `${md} ${when}`, DAY_HRS, true);
            return;
          }

          // 7) 其他未知字樣：保留為備註型（以計次呈現，避免遺漏）
          // 但「非出勤日打卡」完全不統計、直接略過
          if (p && p !== "--" && !/非出勤日打卡/.test(p)) {
             addAgg(map, ym, branch, name, "其他異常", { cnt:1 }, `${md} ${p}`, DAY_HRS, true);
          }

        });
      }
    });
    // —— 遲到免扣後處理：每人每月，遲到⚠️中「≤5 分鐘」者，優先挑大的 3 筆免扣 —— 
    for (const [key, rec] of map.entries()) {
         const [ym, branch, name, typ] = key.split('|');
         if (typ === '遲到⚠️' && Array.isArray(rec._lateEvents) && rec._lateEvents.length) {
    // 候選：分鐘 ≤ 門檻
    const candidates = rec._lateEvents.filter(e => e.mins <= FREE_LATE_MIN);
    if (candidates.length > 0) {
      // 由大到小排序（大的優先免）
      candidates.sort((a,b) => (b.mins - a.mins) || a.detail.localeCompare(b.detail));
      const waived = candidates.slice(0, FREE_LATE_COUNT);

      // 先把免扣事件搬到「遲到(不扣)」
      const waivedSet = new Set(waived.map(e => e.detail));
      let waivedMins = 0, waivedCount = 0;
      waived.forEach(e => {
        waivedMins  += e.mins;
        waivedCount += 1;
        // 直接新增到「遲到(不扣)」的彙總（備註標示免扣）
        addAgg(map, ym, branch, name, "遲到(不扣)", { mins: e.mins, cnt: 1 }, `${e.detail}（不扣）`, DAY_HRS, true);
      });

      // 從「遲到⚠️」移除對應分鐘／次數與明細
      rec.totalMins = Math.max(0, rec.totalMins - waivedMins);
      rec.count     = Math.max(0, rec.count - waivedCount);
      rec.detail    = rec.detail.filter(d => !waivedSet.has(d));
      map.set(key, rec);
    }
  }
}

    let dangerCount = 0; // 本次輸出偵測到的 早退/曠職 筆數

    // 組輸出列（固定忽略 0 天 0 時）
    const rowsOut = [];
    for (const [key, val] of map.entries()) {
      const [ym, branch, name, typ] = key.split("|");
      let subtotal = "";
      let remark = "";

      // A) 計次型：漏打卡 / 非出勤日打卡 / 補打卡單 / 其他異常
      if (COUNT_TYPES.has(typ) || typ === "其他異常") {
        subtotal = `${val.count} 次`;
        remark = val.detail.join("、");
        rowsOut.push([ym, branch, name, typ, subtotal, remark]);
        continue;
      }

      // B) 分鐘型：遲到(不扣) / 遲到⚠️ / 早退 / 曠職
      if (/^(?:遲到|早退|曠職)/.test(typ)) {
         // 若免扣搬移後，這筆只剩 0 分鐘、0 次，就不輸出了
         if (((val.totalMins || 0) === 0) && ((val.count || 0) === 0)) continue;

         const isDanger = (typ === "早退" || typ === "曠職");
         if (isDanger) dangerCount++;

         subtotal = `${val.totalMins}分鐘 (${val.count} 次)`;
         remark = val.detail.join("、");
         rowsOut.push([ym, branch, name, typ, subtotal, remark]);
         continue;
         }




      // C) 小時計：請假/加班等（維持原樣）
      const hours = Number(val.totalHours || 0);
      if (hours === 0) continue; // 忽略 0 天 0 時
      subtotal = fmtDayHour(hours, DAY_HRS);
      remark = val.detail.join("、");
      rowsOut.push([ym, branch, name, typ, subtotal, remark]);
    }

    // 排序：年月、分校、姓名、類型
    rowsOut.sort((a,b)=> a[0].localeCompare(b[0]) || a[1].localeCompare(b[1]) || a[2].localeCompare(b[2]) || a[3].localeCompare(b[3]));
    // —— 本月非全勤名單：遲到⚠️≥1、事/病假>0小時、漏打卡>3次 —— 
    const notFullMap = new Map(); // key = ym|branch|name
         for (const [k, v] of map.entries()) {
         const [ym, branch, name, typ] = k.split("|");
         const key = `${ym}|${branch}|${name}`;
         const rec = notFullMap.get(key) || { ym, branch, name, reasons: [] };

         // 1) 有遲到⚠️（至少 1 次）
         if (typ === "遲到⚠️" && (v.count || 0) > 0) {
         rec.reasons.push("遲到⚠️");
         }
         // 2) 有事假 / 病假（>0 小時）
         if ((typ === "事假" || typ === "病假") && (v.totalHours || 0) > 0) {
         // 小時計直接顯示多少小時，視情況可改四捨五入
         rec.reasons.push(`${typ}${v.totalHours}時`);
         }
         // 3) 漏打卡次數 > 3
         if (typ === "漏打卡" && (v.count || 0) > 3) {
         rec.reasons.push(`漏打卡${v.count}次`);
         }

  notFullMap.set(key, rec);
}

// 只留真的有原因的人（reasons 至少 1 條）
const notFullRows = [...notFullMap.values()]
  .filter(x => x.reasons.length > 0)
  .sort((a,b)=> a.ym.localeCompare(b.ym)
    || a.branch.localeCompare(b.branch)
    || a.name.localeCompare(b.name));

    // 畫表
    // 主表
const thead = `<thead><tr><th>年月</th><th>分校</th><th>姓名</th><th>假別/類型</th><th>小計</th><th>備註</th></tr></thead>`;
const tbody = `<tbody>${
  rowsOut.map(r=>{
    return `<tr>${
      r.map((c,i)=>{
        const danger = (i===3 && /^(早退|曠職)$/.test(String(c)));
        return `<td${danger?' class="danger"':''}>${escapeHtml(c)}</td>`;
      }).join("")
    }</tr>`;
  }).join("")
}</tbody>`;

// 先組主表 HTML
// 先組主表 HTML（在提示文字中放一顆 copy 按鈕）
let html = `
  <div class="hint" style="margin-bottom:8px">
    共 ${rowsOut.length} 列，
    <button id="copyTSV" class="pill">複製下面表格</button>
    可貼回 Google Sheet。
  </div>
  <div style="overflow:auto"><table>${thead}${tbody}</table></div>
`;


// 再加「本月非全勤名單」（有資料才畫）
if (notFullRows.length > 0) {
  const thead2 = `<thead><tr><th>年月</th><th>分校</th><th>姓名</th><th>非全勤原因</th></tr></thead>`;
  const tbody2 = `<tbody>${
    notFullRows.map(r=>{
      return `<tr>
        <td>${escapeHtml(r.ym)}</td>
        <td>${escapeHtml(r.branch)}</td>
        <td>${escapeHtml(r.name)}</td>
        <td>${escapeHtml(r.reasons.join("、"))}</td>
      </tr>`;
    }).join("")
  }</tbody>`;
  html += `<div class="hint" style="margin:16px 0 8px">本月非全勤 <b>${notFullRows.length}</b> 人</div>
  <div style="overflow:auto"><table>${thead2}${tbody2}</table></div>`;
}

// 1) 寫回畫面（主表 + 非全勤表）
$("#out").innerHTML = html;

// 2) 渲染完再綁定新產生的按鈕
const copyBtn = document.querySelector("#out #copyTSV");
if (copyBtn) {
  copyBtn.addEventListener("click", copyTSV);
}

// 3) 有警示再跳 TOAST（不會被 #out 覆蓋）
if (dangerCount > 0) {
  toast(`偵測到 <b>${dangerCount}</b> 筆「早退／曠職」。請確認是否應補假單。`, 12000);
}



    // TSV
    const headerRow = ["年月","分校","姓名","假別/類型","小計","備註"];
    lastTSV = [headerRow, ...rowsOut].map(cols=>cols.map(v=>String(v??"").replaceAll("\t"," ")).join("\t")).join("\n");
  }

  function copyTSV(){
    if(!lastTSV){ alert("還沒有可複製的內容，請先產生表格。"); return; }
    navigator.clipboard.writeText(lastTSV).then(()=>{ alert("已複製，可直接貼到要給Candy的表格！"); });
  }

 function addAgg(map, ym, branch, name, typ, val, detailStr, dayHrs){
  // 將「補打卡單」視同「漏打卡」
  const normalizedTyp = (typ === "補打卡單") ? "漏打卡" : typ;

  const key = `${ym}|${branch}|${name}|${normalizedTyp}`;
  const rec = map.get(key) || { 
    totalHours: 0, 
    totalMins: 0, 
    count: 0, 
    detail: [], 
    dayHrs,
    _detailSet: new Set(),   // 去重用
    _lateEvents: []          // 用來之後做「遲到免扣」挑大筆
  };

  const isObj = val && typeof val === 'object';
  const dkey  = (detailStr || "").trim();

  // 對分鐘/計次型，先用 detail 去重，避免重複累加
  if (isObj && dkey && rec._detailSet.has(dkey)) {
    map.set(key, rec);
    return;
  }

  if (typeof val === 'number') {
    // 小時計（請假、加班等）
    rec.totalHours += val;
    rec.detail.push(detailStr);
  } else if (isObj) {
    // 分鐘/次數型
    if ('mins' in val) { 
      rec.totalMins += (val.mins || 0); 
      rec.count     += (val.cnt  || 1); 
      rec.detail.push(detailStr); 
      // 若是遲到（不含不扣），記錄事件清單，供「免扣」演算法挑選
      if (/^遲到/.test(normalizedTyp)) {
        rec._lateEvents.push({ mins: Number(val.mins||0), detail: detailStr });
      }
    }
    if ('miss' in val) { 
      rec.count += (val.miss || 1); 
      rec.detail.push(detailStr); 
    }
    if ('cnt' in val && !('mins' in val) && !('miss' in val)) { 
      // 純計次（例如 非出勤日打卡 / 其他異常）
      rec.count += (val.cnt || 1); 
      rec.detail.push(detailStr); 
    }
  }

  if (isObj && dkey) rec._detailSet.add(dkey);
  map.set(key, rec);
}

  // —— 工具 —— 
  function pickHeader(headers, pattern, fallback){ return headers.find(h=>pattern.test(h)) || fallback; }
  function tsvParse(text){
    const lines = text.split(/\r?\n/).filter(x => x.trim().length > 0);
    if(!lines.length) return {headers:[], rows:[], err:"空白內容"};
    const firstCols = lines[0].split("\t");
    const headerLike = firstCols.some(c => /員工編號|姓名|打卡日期|請假時數|假別|加班時數|出勤異常/.test(c));
    const headers = headerLike ? firstCols.map(h => h.trim()) : headersDefault.slice();
    const dataLines = headerLike ? lines.slice(1) : lines;
    const rows = dataLines.map(l => {
      const cols = l.split("\t");
      const o = {};
      headers.forEach((h,i) => o[h] = (cols[i] ?? "").trim());
      return o;
    });
    return {headers, rows, err:null};
  }

  function toNumber(v){
  const s = String(v ?? "");
  // 若像 "12:30"、"12:30~14:00" 這種時間字串，直接視為 0，避免誤抓成 12 小時
  if (/[~:]/.test(s)) return 0;
  const m = s.match(/-?\d+(?:\.\d+)?/);
  return m ? Number(m[0]) : 0;
  }

  function hhmmToHours(v){
    const s = String(v || "").trim();
    // 例如 "1:30" 或 "01:30:00"
    const m = s.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
    if(!m) return toNumber(s); // 不是時間格式就走原本數字擷取（支援 "1.5" 這種）
    const h = Number(m[1] || 0);
    const min = Number(m[2] || 0);
    const sec = Number(m[3] || 0);
    return h + min/60 + sec/3600;
  }

  function toYM(yyyyMMdd){ const m = String(yyyyMMdd).match(/(\d{4})[\/\-](\d{1,2})/); if(!m) return yyyyMMdd||""; return `${m[1]}-${String(m[2]).padStart(2,'0')}`; }
  function toMD(yyyyMMdd){ const m = String(yyyyMMdd).match(/(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})/); if(!m) return yyyyMMdd||""; return Number(m[2])+"/"+Number(m[3]); }
  function pieceDayHour(h, dayHrs){ const d = Math.floor(h / dayHrs); const rem = Math.round((h - d*dayHrs)*100)/100; return {d, rem}; }
  function fmtDayHour(h, dayHrs){ const {d, rem} = pieceDayHour(Number(h)||0, dayHrs); return `${d} 天 ${rem} 時`; }
  function fmtPiece(h, dayHrs){ const {d, rem} = pieceDayHour(Number(h)||0, dayHrs); if(d>0 && rem===0) return `${d}天`; if(d===0 && rem>0) return `${rem}時`; if(d>0 && rem>0) return `${d}天 ${rem}時`; return `0時`; }
  function escapeHtml(s){ return String(s).replace(/[&<>"]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[c])); }
})();
//TOAST函式
function toast(msg, ms = 12000){
  const wrap = document.getElementById("toast");
  if(!wrap) return;

  const el = document.createElement("div");
  el.className = "toast";
  el.innerHTML = msg;

  // 點一下手動關閉
  el.addEventListener("click", () => { if (el.parentNode) el.parentNode.removeChild(el); });

  wrap.appendChild(el);

  // 先設定過渡，再做淡出
  el.style.transition = "opacity .3s";

  const fadeDelay = Math.max(300, ms) - 300;
  setTimeout(() => {
    if (!el.parentNode) return;
    el.style.opacity = "0";
  }, fadeDelay);

  setTimeout(() => {
    if (el.parentNode) el.parentNode.removeChild(el);
  }, Math.max(300, ms));
}


</script>

</body>
</html>
